"Problem 1"
(define (make-clock hour minute)
  (let ((min (number->string minute)))  
    (if (< (string->number min) 10)
        (set! min (string-append "0" min))
        min)
    (define (tick)
      (if (< (string->number min) 9)
          (set! min (string-append "0" (number->string (+ (string->number min) 1))))
          (set! min (number->string (+ (string->number min) 1))))
      (if (= (string->number min) 60)
          (begin (set! hour (+ 1 hour)) (set! min "00")))
      (if (= hour 24)
          (set! hour 0)))    
    (define (time)
      (cond ((= hour 0)
             (string-append "12:" min " AM\n"))
            ((= hour 24)
             (string-append (number->string (- hour 12)) ":" min " AM\n"))
            ((> hour 12)  
             (string-append (number->string (- hour 12)) ":" min " PM\n" ))
            ((= hour 12)
             (string-append (number->string hour) ":" min " PM\n"))
            (else (string-append (number->string hour) ":" min " AM\n" ) )))         
    (define (military)
      (if (< hour 10)
          (string-append "0" (number->string hour) ":" min "\n")
          (string-append (number->string hour) ":" min "\n")))      
    (lambda (method)
      (cond ((eq? method 'tick) tick)
            ((eq? method 'time) time)
            ((eq? method 'military) military)))))

"Problem 2"
(define (make-stack)
  (let ((S '())) ;; internal stack variables
    (define (empty?) (null? S)) ;; stack methods
    (define (push x) (set! S (cons x S)))
    (define (pop) (let ((top (car S)))
                    (begin (set! S (cdr S))
                           top)))
    (define (top)(car S))
    (define (dispatcher method)
      (cond ((eq? method 'top) top)
            ((eq? method 'pop) pop)
            ((eq? method 'push) push)
            ((eq? method 'empty?) empty?))) ;;the dispatcher
    dispatcher))
"Problem 3"
(define (make-stack)
  (let ((stack (list)))
    (define (push x) (set! stack (cons x stack)))
    (define (top) (car stack))
    (define (pop) (let ((element (car stack)))
                    (begin (set! stack (cdr stack)) element)))
    (define (empty?) (null? stack))
    (lambda (method)
    (cond ((eq? method 'push) push)
      ((eq? method 'pop ) pop)
      ((eq? method 'top ) top)
      ((eq? method 'empty?) empty?)))))
(define (eval-postfix p)
    (let ((postfix p)
             (ops (make-stack)))
         (define (process-operation op)
           (cond ((eq? op #\+) ((ops 'push) (+ ((ops 'pop)) ((ops 'pop)))))
             ((eq? op #\-) ((ops 'push) (let ((op2 ((ops 'pop)))
                                                      (op1 ((ops 'pop))))
                                                  (- op1 op2))))
                                              ((eq? op #\*) ((ops 'push) (* ((ops 'pop)) ((ops 'pop)))))
                                              ((eq? op #\/) ((ops 'push) (let ((op2 ((ops' pop)))
                                                                               (op1 ((ops 'pop))))
                                                                                   (/ op1 op2))))
                                                                               ((eq? op #\^) ((ops 'push) (let ((op2 ((ops 'pop)))
                                                                                                                        (op1 ((ops' pop))))
                                                                                                                    (expt op1 op2))))))
                                                                                                                (define ( process-exp)
                                                                                                                  (cond ((null? postfix) ((ops 'top)))
                                                                                                                    ((number? (car postfix)) (begin ((ops 'push ) (car postfix))
                                                                                                                                                   (set! postfix (cdr postfix))
                                                                                                                                                   (process-exp)))
                                                                                                                                               (else (begin (process-operation (car postfix))
                                                                                                                                                        (set! postfix (cdr postfix))
                                                                                                                                                        (process-exp)))))
                                                                                                                                                    (begin (process-exp)
                                                                                                                                                      ((ops 'top)))))

"Problem 4"
(define (value tree) (car tree))
(define (left tree) (cadr tree))
(define (right tree) (caddr tree))

(define (dfs T)
  (let ((dfs-t (make-stack)))
    (define (dfs-help)
      (cond ((not ((dfs-t 'empty?)))
             (let ((x ((dfs-t 'pop))))
               (begin (cond ((not (null? (right x)))((dfs-t 'push)(right x))))
                      (cond ((not (null? (left x)))((dfs-t 'push)(left x))))
                      (cons (value x)(dfs-help)))))
            (else (list))))
    (begin ((dfs-t 'push) T)
           (dfs-help))))

"Problem 5"
(define (make-queue)
  (let ((head '())
        (tail '()))
    (define (empty?)(null? head))
     (define (enqueue x)
       (if (null? head)
           (begin
             (set! head (cons x (list)))
             (set! tail head))
           (begin
             (set-cdr! tail (cons x (list)))
             (set! tail (cdr tail)))))
     (define (dequeue)
       (let ((return (car head)))
         (begin
           (set! head (cdr head)) return )))
     (define (dispatcher method)
       (cond ((equal? method 'empty?) empty?)
             ((equal? method 'enqueue) enqueue)
             ((equal? method 'dequeue) dequeue))) dispatcher))

(define (bfs T)
  (let ((bfs-t (make-queue)))
    (define (bfs-help)
      (cond ((not ((bfs-t 'empty?)))
             (let ((x ((bfs-t 'dequeue))))
               (begin (cond ((not (null? (left x))) ((bfs-t 'enqueue) (left x))))
                      (cond ((not (null? (right x))) ((bfs-t 'enqueue) (right x))))
                      (cons (value x) (bfs-help)))))
            (else (list))))
    (begin ((bfs-t 'enqueue) T)
           (bfs-help))))
